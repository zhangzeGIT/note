* [一、虚拟机](#一虚拟机)
    * [内存模型](#内存模型)
    * [判断对象是否存活的算法](#判断对象是否存活的算法)
    * [引用类型](#引用类型)
* [二、如何进行SQL优化](#二如何进行SQL优化)
* [三、BTree&B+Tree](#三BTree&B+Tree)
* [四、聚集索引VS非聚集索引](#四聚集索引VS非聚集索引)
* [五、MVCC](#五MVCC)
* [六、事务性质](#六事务性质)
* [七、事务隔离级别](#七事务隔离级别)



# 虚拟机

## 内存模型

本地方法栈：为虚拟机使用到的Native方法服务，其他同虚拟机栈，HotSpot将二者合为一

虚拟机栈：线程私有，每个方法在执行的同时创建一个栈帧用于存储局部变量，操作数栈，动态链接，方法出口等
          此区域异常StackOverflowError,OutOfMemoryError

程序计数器：线程私有，改变计数器值获取下一条需要的字节码指令

方法区：线程共享，存储类信息，常量，静态变量，即时变异器编译的代码，低版本用堆中的永久代实现
        1.8将永久代数据分到了堆和元空间中
        元空间：存储类的元信息，放在直接内存
        堆：静态变量和常量池等放入堆中
        此区域异常：OutOfMemoryError

运行时常量池：方法区一部分，存储常量信息，详细参考方法区

java堆：线程共享，存放对象实例

随着JIT编译器的发展与逃逸分析技术成熟，栈上分配、标量替换优化技术，所有对象都分配在堆上也不是很绝对了

<div align="center">
    <img src="https://github.com/zhangzeGIT/note/blob/master/assets/java/内存模型.jpg" width="600px">
</div>

## 判断对象是否存活的算法

引用计数法：无法解决相互引用问题

可达性分析：通过GC Roots判断

    ①：虚拟机栈（栈帧中的本地变量表）中引用的对象
    ②：本地方法栈中JNI（native方法）应用的对象
    ③：方法区中静态类属性，常量引用的对象

## 引用类型

强引用：只要引用存在，就不会回收

软引用：描述一些还有用但非必须的对象，如果第一次回收还是没有足够内存，那就进行第二次回收

弱引用：非必须对象，生存到下一次GC发生之前

虚引用：将对象设置成虚引用的唯一目的是，能在这个对象被GC时收到一个系统通知












